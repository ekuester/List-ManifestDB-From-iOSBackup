//
//  ViewController.swift
//  List ManifestDB
//   see what is covered under the hood of IOS
//
//  Program for parsing the Backup files of IOS generated by iTunes for iPad and iPhone
//   iTunes versions higher than 12.5 or so ( not shure when IT happened )
//   are using an other method for a backup.
//   The main information is stored in a SQLite database Manifest.db
//
//  Use the program for extracting of stored files which could not be recoverd otherwise.
//  Much of the code from the older program to decode Manifest.mbdb was recycled ;-)
//
//  Access to SQLite relies on <https://gist.github.com/zgchurch/3bac5443f6b3f407fe65>
//
//  Created by Erich Küster on October 3, 2016
//  Copyright © 2016 Erich Küster. All rights reserved.
//

import Cocoa

class FileInfo: NSObject {
    var fileID: String = ""
    var domain: String = ""
    var relativePath: String = ""
    var flags: Int64 = 0
}

class ViewController: NSViewController, NSComboBoxDataSource, NSTableViewDataSource, NSTableViewDelegate {

    @IBOutlet var statusTextView: NSTextView!
    @IBOutlet weak var backupTableView: NSTableView!
    @IBOutlet weak var domainComboBox: NSComboBox!
    @IBOutlet weak var selectTextView: NSTextField!

    var directoryURL: URL!
    var userDirectoryURL: URL!
    var backupItems: Array<FileInfo> = []
    var filteredItems: Array<FileInfo> = []
    var domainItems: Array<FileInfo> = []
    var textStorage: NSTextStorage?

    var sqliteDB: OpaquePointer? = nil
    // attributes for strings
    var normalAttributes: [String:AnyObject] = [:]

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        // assign TableView specialties
        backupTableView.delegate = self
        backupTableView.dataSource = self
        domainComboBox.dataSource = self
        domainComboBox.numberOfVisibleItems = 10
        textStorage = statusTextView.textStorage
        let paragraphStyle = NSMutableParagraphStyle()
        // default values for text output
        paragraphStyle.paragraphSpacingBefore = 0.0
        paragraphStyle.paragraphSpacing = 0.0
        paragraphStyle.maximumLineHeight = 0.0
        normalAttributes = [
            NSFontAttributeName : NSFont(name: "Courier New", size: 12)!,
            NSForegroundColorAttributeName : NSColor.black,
            NSParagraphStyleAttributeName : paragraphStyle
        ]
    }
 
    override var representedObject: Any? {
        didSet {
            // Update the view, if already loaded.
            
        }
    }

    // Methods for NSComboView
    func numberOfItems(in comboBox: NSComboBox) -> Int {
        let numberOfItems: Int = filteredItems.count
        return numberOfItems
    }
    
    func comboBox(_ comboBox: NSComboBox, objectValueForItemAt index: Int) -> Any? {
        let filteredItem: FileInfo = filteredItems[index]
        return filteredItem.domain
    }

    // Methodes for NSTableView
    func numberOfRows(in tableView: NSTableView) -> Int
    {
        let numberOfRows: Int = domainItems.count
        return numberOfRows
    }

    func tableView(_ tableView: NSTableView, objectValueFor tableColumn: NSTableColumn?, row: Int) -> Any?
    {
        let domainItem: FileInfo = domainItems[row]
        return domainItem.value(forKey: tableColumn!.identifier)
    }

    @IBAction func comboSelected(_ sender: NSComboBox) {
        let sv = domainComboBox.stringValue
        domainItems = backupItems.filter {$0.domain == sv}
        if (domainItems.count > 0) {
            backupTableView.reloadData()
        }
        else {
            textStorage?.append(NSAttributedString(string: "> please select a domain item from combobox\n", attributes: normalAttributes))
        }
    }

    @IBAction func tableRowSelected(_ sender: NSTableView) {
        let selectedRow = sender.selectedRow
        if (domainItems.count > 0) {
            // only if data present
            let backupItem = domainItems[selectedRow]
            if (selectedRow != -1) {
                if (backupItem.flags == 1) {
                    // only if selection is file
                    let fileManager = FileManager.default
                    textStorage?.append(NSAttributedString(string: "selected filename: \(backupItem.relativePath)\n", attributes: normalAttributes))
                    let fileID = backupItem.fileID
                    let index = fileID.index(fileID.startIndex, offsetBy: 2)
                    let fileURL = directoryURL.appendingPathComponent(fileID.substring(to: index))
                    let backupURL = fileURL.appendingPathComponent(backupItem.fileID)
                    if (fileManager.fileExists(atPath: backupURL.path)) {
                        let copyFilename = NSString(string: backupItem.relativePath).lastPathComponent as String
                        // generate File Open Dialog class
                        let copyDialog:NSOpenPanel = NSOpenPanel()
                        copyDialog.title = NSLocalizedString("Select directory for copy", comment: "title of copyPanel")
                        copyDialog.nameFieldStringValue = copyFilename
                        // set path for initial directory
                        copyDialog.directoryURL = userDirectoryURL
                        //copyDlg.allowedFileTypes = ["mbdb"]
                        copyDialog.allowsMultipleSelection = false;
                        copyDialog.canChooseDirectories = true;
                        copyDialog.canCreateDirectories = true;
                        copyDialog.canChooseFiles = false;
                        copyDialog.beginSheetModal(for: view.window!, completionHandler: { response in
                            if response == NSFileHandlingPanelOKButton {
                                // NSFileHandlingPanelOKButton is Int(1)
                                if let selectedURL = copyDialog.urls.first {
                                    let copyFileURL = selectedURL.appendingPathComponent(copyFilename, isDirectory: false)
                                    do {
                                        try fileManager.copyItem(at: backupURL, to: copyFileURL)
                                        self.textStorage?.append(NSAttributedString(string: "copy to \(copyFileURL) was successful\n", attributes: self.normalAttributes))
                                    }
                                    catch {
                                        print("copy to \(copyFileURL) failed")
                                    }
                                }
                            }
                            else {
                                self.textStorage?.append(NSAttributedString(string: "no location for copy selected (cancel pressed)\n", attributes: self.normalAttributes))
                            }
                        })
                    }
                    else {
                        textStorage?.append(NSAttributedString(string: "no copy, expected file at \(backupURL) does not exist\n", attributes: normalAttributes))
                    }
                }
            }
        }
    }

    func processDatabase(_ url: URL) {
        // check if a db file was analyzed already
        if (backupItems.count > 0) {
            // TextView loeschen
            textStorage?.replaceCharacters(in: NSMakeRange(0, (textStorage!.length)), with: "")
            // reset table view
            backupItems.removeAll(keepingCapacity: false)
            domainItems.removeAll(keepingCapacity: false)
            domainComboBox.stringValue = ""
            backupTableView.reloadData()
        }
        textStorage?.append(NSAttributedString(string: "data base found at \(url)\n", attributes: normalAttributes))
        if sqlite3_open(url.path, &sqliteDB) == SQLITE_OK {
            var statement: OpaquePointer? = nil
            if sqlite3_prepare_v2(sqliteDB, "select fileID, domain, relativePath, flags from Files", -1, &statement, nil) != SQLITE_OK {
                let errmsg = String(cString: sqlite3_errmsg(sqliteDB))
                print("error preparing select: \(errmsg)")
            }
            else {
                while sqlite3_step(statement) == SQLITE_ROW {
                    let fileInfo = FileInfo()
                    if let fileID = sqlite3_column_text(statement, 0) {
                        fileInfo.fileID = String(cString: fileID)
//                        Swift.print("fileID = \(fileInfo.fileID) ; ", terminator: "")
                    }
                    if let domain = sqlite3_column_text(statement, 1) {
                        fileInfo.domain = String(cString: domain)
//                        Swift.print("domain = \(fileInfo.domain) ; ", terminator: "")
                    }
                    if let relativePath = sqlite3_column_text(statement, 2) {
                        fileInfo.relativePath = String(cString: relativePath)
//                        Swift.print("relativePath = \(fileInfo.relativePath)")
                    } else {
                        Swift.print("relativePath not found")
                    }
                    let flags = sqlite3_column_int64(statement, 3)
                    fileInfo.flags = flags
//                    Swift.print("flags = \(fileInfo.flags)")
                    backupItems.append(fileInfo)
                }
            }
            if sqlite3_finalize(statement) != SQLITE_OK {
                let errmsg = String(cString: sqlite3_errmsg(sqliteDB))
                Swift.print("error finalizing prepared statement: \(errmsg)")
            }
            statement = nil
            if sqlite3_close(sqliteDB) != SQLITE_OK {
                Swift.print("error closing database")
            }
            sqliteDB = nil
//            Swift.print("count backupitems: \(backupItems.count)")
            backupTableView.reloadData()
            // get "naked" domain when relativePath is empty
            filteredItems = backupItems.filter {$0.relativePath.isEmpty}
            // now sort in alphabetical order
            filteredItems = filteredItems.sorted{$0.domain < $1.domain}
            selectTextView.isHidden = false
            domainComboBox.isHidden = false
        }
    }


    @IBAction func openSelected(_ sender: NSButton) {
        // generate File Open Dialog class
        let databaseDialog: NSOpenPanel = NSOpenPanel()
        databaseDialog.title = NSLocalizedString("Select Manifest.db file", comment: "title of openPanel")
        let dbFile = "Manifest.db"
        databaseDialog.nameFieldStringValue = dbFile
        // set user's directory
        let userDirectoryPath: NSString = "~"
        
        userDirectoryURL = URL(fileURLWithPath: userDirectoryPath.expandingTildeInPath)
        databaseDialog.directoryURL = userDirectoryURL.appendingPathComponent("Library/Application Support/MobileSync/Backup",
                                                                       isDirectory: true)
        databaseDialog.allowedFileTypes = ["db"]
        databaseDialog.allowsMultipleSelection = false;
        databaseDialog.canChooseDirectories = false;
        databaseDialog.canCreateDirectories = false;
        databaseDialog.canChooseFiles = true;
        databaseDialog.beginSheetModal(for: view.window!, completionHandler: { response in
            if response == NSFileHandlingPanelOKButton {
                // NSFileHandlingPanelOKButton is Int(1)
                if let fileURL = databaseDialog.urls.first {
                    self.directoryURL = fileURL.deletingLastPathComponent()
                    self.processDatabase(fileURL)
                }
            }
        })
    }

}
